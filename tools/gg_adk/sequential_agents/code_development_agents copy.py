# --- 1. Define Sub-Agents for Each Pipeline Stage ---

from dotenv import load_dotenv
from google.adk.agents import LlmAgent
from google.adk.agents.sequential_agent import SequentialAgent

GEMINI_MODEL = "gemini-2.5-flash"  
APP_NAME = "code_dev_team"
USER_ID = "user_1_agent_team"
SESSION_ID = "session_001_agent_team"

load_dotenv()
    
# Code Writer Agent
# Takes the initial specification (from user query) and writes code.
code_writer_agent = LlmAgent(
    name="CodeWriterAgent",
    model=GEMINI_MODEL,
    instruction="""You are a Python Code Generator.
Based *only* on the user's request, write Python code that fulfills the requirement.
Output *only* the complete Python code block, enclosed in triple backticks (```python ... ```). 
Do not add any other text before or after the code block.
""",
    description="Writes initial Python code based on a specification.",
    output_key="generated_code" # Stores output in state['generated_code']
)

# Code Reviewer Agent
# Takes the code generated by the previous agent (read from state) and provides feedback.
code_reviewer_agent = LlmAgent(
    name="CodeReviewerAgent",
    model=GEMINI_MODEL,
    instruction="""You are an expert Python Code Reviewer. 
    Your task is to provide constructive feedback on the provided code.

    **Code to Review:**
    ```python
    {generated_code}
    ```

**Review Criteria:**
1.  **Correctness:** Does the code work as intended? Are there logic errors?
2.  **Readability:** Is the code clear and easy to understand? Follows PEP 8 style guidelines?
3.  **Efficiency:** Is the code reasonably efficient? Any obvious performance bottlenecks?
4.  **Edge Cases:** Does the code handle potential edge cases or invalid inputs gracefully?
5.  **Best Practices:** Does the code follow common Python best practices?

**Output:**
Provide your feedback as a concise, bulleted list. Focus on the most important points for improvement.
If the code is excellent and requires no changes, simply state: "No major issues found."
Output *only* the review comments or the "No major issues" statement.
""",
    description="Reviews code and provides feedback.",
    output_key="review_comments", # Stores output in state['review_comments']
)


# Code Refactorer Agent
# Takes the original code and the review comments (read from state) and refactors the code.
code_refactorer_agent = LlmAgent(
    name="CodeRefactorerAgent",
    model=GEMINI_MODEL,
    instruction="""You are a Python Code Refactoring AI.
Your goal is to improve the given Python code based on the provided review comments.

  **Original Code:**
  ```python
  {generated_code}
  ```

  **Review Comments:**
  {review_comments}

**Task:**
Carefully apply the suggestions from the review comments to refactor the original code.
If the review comments state "No major issues found," return the original code unchanged.
Ensure the final code is complete, functional, and includes necessary imports and docstrings.

**Output:**
Output *only* the final, refactored Python code block, enclosed in triple backticks (```python ... ```). 
Do not add any other text before or after the code block.
""",
    description="Refactors code based on review comments.",
    output_key="refactored_code", # Stores output in state['refactored_code']
)


# --- 2. Create the SequentialAgent ---

# This agent orchestrates the pipeline by running the sub_agents in order.
code_pipeline_agent = SequentialAgent(
    name="CodePipelineAgent",
    sub_agents=[code_writer_agent, code_reviewer_agent, code_refactorer_agent],
    description="Executes a sequence of code writing, reviewing, and refactoring.",
    # The agents will run in the order provided: Writer -> Reviewer -> Refactorer
)

# For ADK tools compatibility, the root agent must be named `root_agent`
root_agent = code_pipeline_agent

from google.genai import types # For creating message Content/Parts

async def call_agent_async(query: str, runner, user_id, session_id):
   """Sends a query to the agent and prints the final response."""
   print(f"\n>>> User Query: {query}")

   # Prepare the user's message in ADK format
   content = types.Content(role='user', parts=[types.Part(text=query)])

   final_response_text = "Agent did not produce a final response." # Default

   # Key Concept: run_async executes the agent logic and yields Events.
   # We iterate through events to find the final answer.
   async for event in runner.run_async(user_id=user_id, session_id=session_id, new_message=content):
      # You can uncomment the line below to see *all* events during execution
      # print(f"  [Event] Author: {event.author}, Type: {type(event).__name__}, Final: {event.is_final_response()}, Content: {event.content}")

      # Key Concept: is_final_response() marks the concluding message for the turn.
      if event.is_final_response():
            if event.content and event.content.parts:
               # Assuming text response in the first part
               final_response_text = event.content.parts[0].text
            elif event.actions and event.actions.escalate: # Handle potential errors/escalations
               final_response_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
            # Add more checks here if needed (e.g., specific error codes)
            break # Stop processing events once the final response is found

   print(f"<<< Agent Response: {final_response_text}")

import asyncio
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner

async def main():
    # SESSION
    session_service = InMemorySessionService()
    print("✅ New InMemorySessionService created for state demonstration.")

    # Create the session, providing the initial state
    session = await session_service.create_session(
        app_name=APP_NAME, 
        user_id=USER_ID,
        session_id=SESSION_ID,
        # state=initial_state 
    )
    print(f"✅ Session '{SESSION_ID}' created for user '{USER_ID}'.")

    # Verify the initial state was set correctly
    retrieved_session = await session_service.get_session(app_name=APP_NAME,
                                                            user_id=USER_ID,
                                                            session_id = SESSION_ID)
    print("\n--- Initial Session State ---")
    if retrieved_session:
        print(retrieved_session.state)
    else:
        print("Error: Could not retrieve session.")

    # RUNNER
    if 'session_service' in globals():
        runner_root = Runner(
            agent=root_agent,
            app_name=APP_NAME,
            session_service=session_service
        )
        print(f"✅ Runner created for tool guardrail agent '{runner_root.agent.name}', using stateful session service.")
    else:
        print("❌ Cannot create runner. 'session_service' is missing.")

    # INTERACT
    async def run_test():
        print("\n--- Testing ---")

        # Use the runner for the agent with both callbacks and the existing stateful session
        # Define a helper lambda for cleaner interaction calls
        interaction_func = lambda query: call_agent_async(query,
                                                        root_agent,
                                                        USER_ID, 
                                                        SESSION_ID 
                                                        )
        # 1. Allowed city (Should pass both callbacks, use Fahrenheit state)
        query = "Write a Python function that find Fibonacci numbers up to n, limit to first 10 numbers."
        print(f"--- ASKING: {query} ---")
        await interaction_func(query)

    # --- Execute the `run_test` async function ---
    # METHOD 1: Direct await (Default for Notebooks/Async REPLs)
    # print("Attempting execution using 'await' (default for notebooks)...")
    # await run_test()

    # METHOD 2: asyncio.run (For Standard Python Scripts [.py])
    print("Executing using 'asyncio.run()' (for standard Python scripts)...")
    try:
        # This creates an event loop, runs your async function, and closes the loop.
        asyncio.run(run_test())
    except Exception as e:
        print(f"An error occurred: {e}")

    # --- Inspect final session state after the conversation ---
    print("\n--- Inspecting Final Session State ---")
    # Use the session service instance associated with this stateful session
    final_session = await session_service.get_session(app_name=APP_NAME,
                                                        user_id=USER_ID,
                                                        session_id= SESSION_ID)
    if final_session:
        # print(f"Last Weather Report: {final_session.state.get('last_weather_report', 'Not Set')}") 
        print(f"Full State Dict: {final_session.state}") # For detailed view
    else:
        print("\n❌ Error: Could not retrieve final session state.")


if __name__ == "__main__":
    asyncio.run(main())